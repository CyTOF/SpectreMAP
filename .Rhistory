# temp
#
# length(unique(values(temp)))
#
#
# ?extent
# extent(temp) # X (columns) = 500, Y (rows) = 501
# length(values(temp))
#
# # x <- unique(temp@extent[1]:temp@extent[2])
# # y <- unique(temp@extent[3]:temp@extent[4])
# #
#
# maxX <- temp@extent[2]
# maxY <- temp@extent[4]
#
# c(0.5:499.5)
# c(0.5:500.5)
#
# x <- c(temp@extent[1]+1:temp@extent[2])
# y <- c(temp@extent[3]+1:temp@extent[4])
#
# z <- matrix(values(temp),
#             length(y),
#             length(x),
#             byrow = TRUE)
#
# # https://gis.stackexchange.com/questions/171124/data-frame-to-spatialpolygonsdataframe-with-multiple-polygons
# dt <- as.data.table(c(1:nrow(z)))
# names(dt) <- "RowY" # Rows = 501
# dt
#
# dt <- cbind(dt, z)
# dt
#
# names(dt)[length(names(dt))]
#
# dt <- gather(dt, 'ColumnX', value = 'Value', names(dt)[2]:names(dt)[length(names(dt))])
# dt$ColumnX <- gsub("V", "", dt$ColumnX)
# dt$ColumnX <- as.numeric(dt$ColumnX)
#
# names(dt)
# dt <- dt[,c(2,1,3)] # Reorder columns to X/columns, Y/rows, Values
# names(dt)
#
# setorderv(dt, 'Value')
# dt
#
# max(dt$RowY)
# max(dt$ColumnX)
#
# dt.list <- split(dt, dt$Value)
# dt.list
# dt.list <- lapply(dt.list, function(x) { x["Value"] <- NULL; x })
# dt.list
#
# do.list.summary(dt.list)
#
# str(dt.list[[969]])
#
# ps <- sapply(dt.list, Polygon)
# p1 <- lapply(seq_along(ps), function(i) Polygons(list(ps[[i]]),
#                                                  ID = names(dt.list)[i]  ))
#
# my_spatial_polys <- SpatialPolygons(p1)
# extent(my_spatial_polys)[1] <- 0
# extent(my_spatial_polys)[3] <- 0
#
#
# my_spatial_polys_df <- SpatialPolygonsDataFrame(my_spatial_polys,
#                                                 data.frame(id = unique(dt$Value),
#                                                            row.names = unique(dt$Value)))
#
# names(my_spatial_polys_df) <- mask.name <- "cell_mask"
#
#
#
# my_outline <- fortify(my_spatial_polys_df)
#
# #plot(my_spatial_polys)
# plot(my_spatial_polys_df)
outline <- fortify(polygon)
spatial.dat[[i]]$MASKS[[mask.name]][["outlines"]] <- outline
message("... outlines complete")
centroids <- gCentroid(polygon,byid=TRUE)
spatial.dat[[i]]$MASKS[[mask.name]][["centroids"]] <- centroids
message("... centroids complete")
#end.time <- Sys.time()
#time.taken <- end.time - start.time
#message(paste0("----- ROI ", i, " complete"))
#message(paste0("----- ROI ", i, " complete in ", time.taken, " minutes"))
}
# spatial.dat[[1]]$rasters
# spatial.dat[[1]]$cell_mask
# spatial.dat[[1]]$cell_mask_polygons
# spatial.dat[[1]]$cell_mask_outlines
# spatial.dat[[1]]$cell_mask_centroids
message("Returning spatial data")
return(spatial.dat)
}
plot(res[res$cell_mask > 0,])
res[res$cell_mask > 0,]
polygon
plot(res[res$cell_mask > 1,])
res[res$cell_mask > 1,]
[res$cell_mask > 1
res$cell_mask > 1
res$cell_mask
unique(res$cell_mask)
plot(res[res$cell_mask > 100,])
plot(res[res$cell_mask > 200,])
plot(res[res$cell_mask > 500,])
res$cell_mask
plot(res[res$cell_mask > 3700,])
res[res$cell_mask > 3700,]
res
stars.mask
mask
stars.mask <- stars::st_as_stars(mask)
stars.mask
? st_as_stars
mask
values(mask)
stars.mask <- stars::st_as_stars(mask, values = values(mask))
stars.mask
stars.mask <- stars::st_as_stars(mask)
stars.mask
sf::st_crs(stars.mask) <- 4326
res <- sf::st_as_sf(stars.mask, # requires the sf, sp, raster and stars packages
as_points = FALSE,
merge = TRUE)
res
res <- sf::st_as_sf(stars.mask, # requires the sf, sp, raster and stars packages
as_points = TRUE,
merge = TRUE)
res <- sf::st_as_sf(stars.mask, # requires the sf, sp, raster and stars packages
as_points = TRUE,
merge = FALSE)
res
res <- sf::st_as_sf(stars.mask, # requires the sf, sp, raster and stars packages
as_points = FALSE,
merge = TRUE,
na.rm = TRUE)
res
res <- sf::st_as_sf(stars.mask, # requires the sf, sp, raster and stars packages
as_points = FALSE,
merge = TRUE,
#na.rm = TRUE)
group = TRUE) # TRUE crashes, FALSE does not
res
stars.mask
? st_as_sf
res <- sf::st_as_sf(stars.mask, # requires the sf, sp, raster and stars packages
as_points = FALSE,
merge = TRUE, remove = TRUE)
res
res <- sf::st_as_sf(stars.mask, # requires the sf, sp, raster and stars packages
as_points = FALSE,
merge = TRUE) #,
res
res <- sf::st_as_sf(stars.mask, # requires the sf, sp, raster and stars packages
as_points = FALSE,
merge = TRUE, fill = TRUE) #,
res
res <- sf::st_as_sf(stars.mask, # requires the sf, sp, raster and stars packages
as_points = FALSE,
merge = TRUE) #,
res
res
# res$cell_mask
# plot(res)
#
# res <- res[res$cell_mask > 0,]
# plot(res)
#
polygon <- sf::as_Spatial(res)
polygon
crs(polygon) <- NA
polygon
polygon$cell_mask
res
polygon
# res$cell_mask
# plot(res)
#
# res <- res[res$cell_mask > 0,]
# plot(res)
#
polygon <- sf::as_Spatial(res, IDs = as.character(values(mask)))
polygon
as.character(values(mask))
# res$cell_mask
# plot(res)
#
# res <- res[res$cell_mask > 0,]
# plot(res)
#
polygon <- sf::as_Spatial(res, IDs = values(mask))
polygon
# res$cell_mask
# plot(res)
#
# res <- res[res$cell_mask > 0,]
# plot(res)
#
polygon <- sf::as_Spatial(res)
res
st_union(res)
res
res <- sf::st_as_sf(stars.mask, # requires the sf, sp, raster and stars packages
as_points = FALSE,
merge = FALSE) #,
res
st_union(res)
test <- st_union(res)
test
test
res
res
cell_mask
st_difference(res)
res
stars.mask <- stars::st_as_stars(mask)
sf::st_crs(stars.mask) <- 4326
res <- sf::st_as_sf(stars.mask, # requires the sf, sp, raster and stars packages
as_points = FALSE,
merge = FALSE) #,
res <- sf::st_as_sf(stars.mask, # requires the sf, sp, raster and stars packages
as_points = FALSE,
merge = FALSE) #,
res
res <- sf::st_as_sf(stars.mask, # requires the sf, sp, raster and stars packages
as_points = FALSE,
merge = TRUE) #,
res
res <- sf::st_as_sf(stars.mask, # requires the sf, sp, raster and stars packages
as_points = TRUE,
merge = TRUE) #,
res
res
res %>%
group_by(ID_2) %>%
summarise(geometry = sf::st_union(geometry)) %>%
ungroup()
res %>%
group_by(cell_mask) %>%
summarise(geometry = sf::st_union(geometry)) %>%
ungroup()
res
res <- res %>%
group_by(cell_mask) %>%
summarise(geometry = sf::st_union(geometry)) %>%
ungroup()
res
# res$cell_mask
# plot(res)
#
# res <- res[res$cell_mask > 0,]
# plot(res)
#
polygon <- sf::as_Spatial(res)
polygon
crs(polygon) <- NA
polygon
names(polygon)
polygon
#' do.create.outlines
#'
#' @import data.table
#'
#' @export
#pypath = "/Library/Frameworks/GDAL.framework/Programs/gdal_polygonize.py"
do.create.outlines <- function(spatial.dat,
mask.name,
method = 'stars' # 'raster', 'stars', 'gdal'
#g.dal.path = NULL
){
### Setup
#message("This is a developmental Spectre-spatial function that is still in testing phase with limited documentation. We recommend only using this function if you know what you are doing.")
require(raster)
require(tiff)
require(rgeos)
require(tidyr)
require(ggplot2)
# polygons.name <- paste0(mask.name, "_polygons")
# outlines.name <- paste0(mask.name, "_outlines")
# centroids.name <- paste0(mask.name, "_centroids")
### Slow or fast version
if(method == 'raster'){
message(paste0("Creating polygons, outlines, and centroids using standard method -- this step may take some time, please be patient"))
}
if(method == 'stars'){
message(paste0("Creating polygons, outlines, and centroids using 'stars' method."))
}
if(method == 'gdal'){
if(length(Sys.which("gdal_polygonize.py")) > 1){
message(paste0("Creating polygons, outlines, and centroids using GDAL -- this step may take some time, please be patient"))
}
}
### Run
for(i in names(spatial.dat)){
# i <- names(spatial.dat)[[1]]
start.time <- Sys.time()
mask <- spatial.dat[[i]]$MASKS[[mask.name]]$maskraster
message(paste0("Processing masks for ROI ", i))
## rasterToPolygons method
if(method == 'raster'){
polygon <- rasterToPolygons(mask, dissolve=TRUE) # This is the long step
spatial.dat[[i]]$MASKS[[mask.name]][["polygons"]] <- polygon
message("... polygons complete")
}
## stars method
if(method == 'stars'){
require(stars)
require(sf)
require(sp)
stars.mask <- stars::st_as_stars(mask)
sf::st_crs(stars.mask) <- 4326
res <- sf::st_as_sf(stars.mask, # requires the sf, sp, raster and stars packages
as_points = FALSE,
merge = TRUE) #,
#na.rm = TRUE)
#group = TRUE) # TRUE crashes, FALSE does not
# rgeos::gIsValid(polygon)
# rgeos::gIsValid(polygon) # FALSE here means that you'll need to run the buffer routine:
# res <- rgeos::gBuffer(polygon, byid = TRUE, width = 0)
res <- res %>%
group_by(cell_mask) %>%
summarise(geometry = sf::st_union(geometry)) %>%
ungroup()
# plot(res[unique(res$cell_mask),])
# plot(res[res$cell_mask > 3700,])
#
# st_difference(res)
# test <- st_union(res)
# test
# res <- res[unique(res$cell_mask),]
# res$cell_mask
# plot(res)
#
# res <- res[res$cell_mask > 0,]
# plot(res)
#
polygon <- sf::as_Spatial(res)
# plot(polygon)
crs(polygon) <- NA
polygon
names(polygon)
#polygon$cell_mask[polygon$cell_mask != 0]
# polygon <- polygon[polygon$cell_mask != 0, ]
#polygon <- polygon[unique(polygon$cell_mask), ]
polygon
spatial.dat[[i]]$MASKS[[mask.name]][["polygons"]] <- polygon
message("... polygons complete")
}
## other workaround options
# temp <- spatial.dat$`20171228_spleen315_500x500_editedforFAS_s1_p9_r2_a2_ac`$MASKS$cell_mask$maskraster
#
# temp@data
# temp
#
# length(unique(values(temp)))
#
#
# ?extent
# extent(temp) # X (columns) = 500, Y (rows) = 501
# length(values(temp))
#
# # x <- unique(temp@extent[1]:temp@extent[2])
# # y <- unique(temp@extent[3]:temp@extent[4])
# #
#
# maxX <- temp@extent[2]
# maxY <- temp@extent[4]
#
# c(0.5:499.5)
# c(0.5:500.5)
#
# x <- c(temp@extent[1]+1:temp@extent[2])
# y <- c(temp@extent[3]+1:temp@extent[4])
#
# z <- matrix(values(temp),
#             length(y),
#             length(x),
#             byrow = TRUE)
#
# # https://gis.stackexchange.com/questions/171124/data-frame-to-spatialpolygonsdataframe-with-multiple-polygons
# dt <- as.data.table(c(1:nrow(z)))
# names(dt) <- "RowY" # Rows = 501
# dt
#
# dt <- cbind(dt, z)
# dt
#
# names(dt)[length(names(dt))]
#
# dt <- gather(dt, 'ColumnX', value = 'Value', names(dt)[2]:names(dt)[length(names(dt))])
# dt$ColumnX <- gsub("V", "", dt$ColumnX)
# dt$ColumnX <- as.numeric(dt$ColumnX)
#
# names(dt)
# dt <- dt[,c(2,1,3)] # Reorder columns to X/columns, Y/rows, Values
# names(dt)
#
# setorderv(dt, 'Value')
# dt
#
# max(dt$RowY)
# max(dt$ColumnX)
#
# dt.list <- split(dt, dt$Value)
# dt.list
# dt.list <- lapply(dt.list, function(x) { x["Value"] <- NULL; x })
# dt.list
#
# do.list.summary(dt.list)
#
# str(dt.list[[969]])
#
# ps <- sapply(dt.list, Polygon)
# p1 <- lapply(seq_along(ps), function(i) Polygons(list(ps[[i]]),
#                                                  ID = names(dt.list)[i]  ))
#
# my_spatial_polys <- SpatialPolygons(p1)
# extent(my_spatial_polys)[1] <- 0
# extent(my_spatial_polys)[3] <- 0
#
#
# my_spatial_polys_df <- SpatialPolygonsDataFrame(my_spatial_polys,
#                                                 data.frame(id = unique(dt$Value),
#                                                            row.names = unique(dt$Value)))
#
# names(my_spatial_polys_df) <- mask.name <- "cell_mask"
#
#
#
# my_outline <- fortify(my_spatial_polys_df)
#
# #plot(my_spatial_polys)
# plot(my_spatial_polys_df)
outline <- fortify(polygon)
spatial.dat[[i]]$MASKS[[mask.name]][["outlines"]] <- outline
message("... outlines complete")
centroids <- gCentroid(polygon,byid=TRUE)
spatial.dat[[i]]$MASKS[[mask.name]][["centroids"]] <- centroids
message("... centroids complete")
#end.time <- Sys.time()
#time.taken <- end.time - start.time
#message(paste0("----- ROI ", i, " complete"))
#message(paste0("----- ROI ", i, " complete in ", time.taken, " minutes"))
}
# spatial.dat[[1]]$rasters
# spatial.dat[[1]]$cell_mask
# spatial.dat[[1]]$cell_mask_polygons
# spatial.dat[[1]]$cell_mask_outlines
# spatial.dat[[1]]$cell_mask_centroids
message("Returning spatial data")
return(spatial.dat)
}
### Review mask names
names(spatial.dat[[1]]$MASKS)
### Calculate polygons and outlines for each mask object
spatial.dat <- do.create.outlines(spatial.dat = spatial.dat,
mask.name = "cell_mask")
spatial.dat
### Calculate polygons and outlines for each mask object
spatial.dat <- do.create.outlines(spatial.dat = spatial.dat,
mask.name = "cell_mask")
str(spatial.dat, 3)
str(spatial.dat[[1]]$MASKS$cell_mask, 1)
spatial.dat <- do.extract(dat = spatial.dat, mask = "cell_mask", name = "CellData", fun = "mean")
str(spatial.dat, 3)
spatial.dat[[1]]$DATA
str(spatial.dat, 3)
spatial.dat[[1]]$DATA
setwd(OutputDirectory)
dir.create("Spatial plots")
setwd("Spatial plots")
as.matrix(names(spatial.dat))
as.matrix(names(spatial.dat[[1]]$RASTERS))
make.spatial.plot(spatial.dat = spatial.dat,
image.roi = '20171228_spleen315_500x500_editedforFAS_s1_p9_r2_a2_ac',
image.channel = "CD20_Dy161")
make.spatial.plot(spatial.dat = spatial.dat,
image.roi = '20171228_spleen315_500x500_editedforFAS_s1_p9_r2_a2_ac',
image.channel = "CD20_Dy161",
mask.outlines = "cell_mask",
cell.dat = "CellData",
cell.col = "CD20_Dy161")
library(devtools)
library(roxygen2)
setwd("/Users/thomasa/Google Drive File Stream/My Drive/_Sydney Cytometry/Libraries (synced)/GitHub/Public github/SpectreMAP/")
document()
str(spatial.dat)
str(spatial.dat, 3)
library(devtools)
library(roxygen2)
setwd("/Users/thomasa/Google Drive File Stream/My Drive/_Sydney Cytometry/Libraries (synced)/GitHub/Public github/SpectreMAP/")
document()
### Load packages
library(Spectre)
library(SpectreMAP)
package.check()
package.load()
library('velox')
library('tiff')
library('raster')
library('rgeos')
library('tidyr') # to use the 'gather' function
library('sp')
library('sf')
library('stars')
