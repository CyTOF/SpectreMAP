#' @export
do.add.percell <- function(spatial.dat,
percell.dat,
roi.col,
name = "per.cell"){
### Setup
message("This is a developmental Spectre-spatial function that is still in testing phase with limited documentation. We recommend only using this function if you know what you are doing.")
### Loop
for(i in names(spatial.dat)){
# i <- "20171228_spleen315_500x500_editedforFAS_s1_p9_r2_a2_ac"
temp <- percell.dat[percell.dat[[roi.col]] == i,]
spatial.dat[[i]]$CPDATA[[name]] <- temp
}
return(spatial.dat)
}
#' do.create.outlines
#'
#' @import data.table
#'
#' @export
#pypath = "/Library/Frameworks/GDAL.framework/Programs/gdal_polygonize.py"
do.create.outlines <- function(spatial.dat,
mask.name,
use.gdal = FALSE
#g.dal.path = NULL
){
### Setup
message("This is a developmental Spectre-spatial function that is still in testing phase with limited documentation. We recommend only using this function if you know what you are doing.")
# polygons.name <- paste0(mask.name, "_polygons")
# outlines.name <- paste0(mask.name, "_outlines")
# centroids.name <- paste0(mask.name, "_centroids")
### Slow or fast version
if(use.gdal == TRUE){
if(length(Sys.which("gdal_polygonize.py")) > 1){
message(paste0("Creating polygons, outlines, and centroids using GDAL -- this step may take some time, please be patient"))
}
}
if(use.gdal == FALSE){
message(paste0("Creating polygons, outlines, and centroids using standard method -- this step may take some time, please be patient"))
}
### Run
for(i in names(spatial.dat)){
# i <- names(spatial.dat)[[1]]
start.time <- Sys.time()
# i <- names(spatial.dat)[[1]]
mask <- spatial.dat[[i]]$MASKS[[mask.name]]$maskraster
message(paste0("Processing masks for ROI ", i))
## Fast version
# if(use.gdal == TRUE){
#   if(length(Sys.which("gdal_polygonize.py")) > 1){
#     polygon <- gdal_polygonizeR(x = mask,  pypath = pypath)
#   } else {
#   }
# }
## Older andslower version
if(use.gdal == FALSE){
polygon <- rasterToPolygons(mask, dissolve=TRUE) # This is the long step
spatial.dat[[i]]$MASKS[[mask.name]][["polygons"]] <- polygon
}
## Python enhanced version
##
# library(parallel)
# cl <- makeCluster(detectCores())
# df <- parSapply(cl, args, myFunction)
##
#install.packages("remotes")
#remotes::install_github("lbusett/sprawl")
# library('sprawl')
#
# install.packages("velox")
# library('velox')
#polygon <- gdal_polygonizeR(mask)
##
# r.to.poly <- sf::as_Spatial(sf::st_as_sf(stars::st_as_stars(mask),
#                                          as_points = FALSE,
#                                          merge = TRUE))
##
#getValues(mask)
## Faster version
#install.packages('stars')
# require('stars')
# x <- st_as_stars(mask) %>%
#   st_as_sf(merge = TRUE) %>% # this is the raster to polygons part
#   st_cast("MULTILINESTRING") # cast the polygons to polylines
#
# plot(x)
## Another fast version
#( e <- extract(r, p) )
outline <- fortify(polygon)
spatial.dat[[i]]$MASKS[[mask.name]][["outlines"]] <- outline
centroids <- gCentroid(polygon,byid=TRUE)
spatial.dat[[i]]$MASKS[[mask.name]][["centroids"]] <- centroids
end.time <- Sys.time()
time.taken <- end.time - start.time
message(paste0("----- ROI ", i, " complete in ", time.taken, " minutes"))
}
# spatial.dat[[1]]$rasters
# spatial.dat[[1]]$cell_mask
# spatial.dat[[1]]$cell_mask_polygons
# spatial.dat[[1]]$cell_mask_outlines
# spatial.dat[[1]]$cell_mask_centroids
message("Returning spatial data")
return(spatial.dat)
}
#' do.extract.cell.dat
#'
#' @import data.table
#'
#' @export
do.extract.cell.dat <- function(spatial.dat,
target.dat){
### Setup
message("This is a developmental Spectre-spatial function that is still in testing phase with limited documentation. We recommend only using this function if you know what you are doing.")
### Extract
dat.list <- list()
for(i in names(spatial.dat)){
roi.dat <- spatial.dat[[i]]$CPDATA[[target.dat]]
nme.vec <- rep(i, nrow(roi.dat))
roi.dat <- cbind("ROI" = nme.vec, roi.dat)
dat.list[[i]] <- roi.dat
}
dat.dt <- rbindlist(dat.list, fill = TRUE)
return(dat.dt)
}
#' do.filter.percell
#'
#' @import data.table
#'
#' @export
do.filter.percell <- function(spatial.dat,
per.cell,
to,
filter.by,
id.col = "ObjectNumber",
x.col = "Location_Center_X",
y.col = "Location_Center_Y",
simplify.cp.colname = TRUE,
value.modifier = 65535){
### Setup
message("This is a developmental Spectre-spatial function that is still in testing phase with limited documentation. We recommend only using this function if you know what you are doing.")
### Loop
for(i in names(spatial.dat)){
# i <- "20171228_spleen315_500x500_editedforFAS_s1_p9_r2_a2_ac"
temp <- spatial.dat[[i]]$CPDATA[[per.cell]]
temp.filtered <- temp[,grepl( filter.by , names(temp)),with = FALSE]
temp.filtered <- temp.filtered * value.modifier
temp.filtered <- cbind(ID = temp[[id.col]],x = temp[[x.col]], y = temp[[y.col]], temp.filtered)
if(simplify.cp.colname == TRUE){
measr <- temp.filtered[,c(1:3),with = FALSE]
chnls <- temp.filtered[,c(4:length(names(temp.filtered))),with = FALSE]
names(chnls) <- sub('.*\\_c', '', names(chnls))
temp.names <- names(chnls)
for(b in c(1:length(temp.names))){
a <- temp.names[[b]]
if(nchar(a) == 1){
a <- paste0("0", a)
}
temp.names[[b]] <- a
}
names(chnls) <- temp.names
neworder <- sort(names(chnls))
chnls <- setcolorder(chnls, neworder)
temp.filtered <- cbind(measr, chnls)
}
spatial.dat[[i]]$CPDATA[[to]] <- temp.filtered
}
### Return
return(spatial.dat)
}
#' do.label.from.polygon
#'
#' @import data.table
#'
#' @export
do.label.from.polygon <- function(spatial.dat,
cell.dat,
mask,
labels,
name = "Label",
id.col = 'ID',
roi.col = 'ROI'#,
#x.col = 'x',
#y.col = 'y'
){
###
# spatial.dat <- spatial.dat
# cell.dat <- cell.dat
# mask <- 'obj_mask'
#
# name = "Label"
# labels <- c("HTC", "CTL", "Background", "Hepatocyte", "cDC", "CD11bpos", "Other immune", "Macrophages")
#
# id.col = 'ID'
# roi.col = 'ROI'
# x.col = 'x'
# y.col = 'y'
TEMP_LABEL_PLACEHOLDER1 <- labels
TEMP_LABEL_PLACEHOLDER1 <- as.data.table(TEMP_LABEL_PLACEHOLDER1)
###
rois <- names(spatial.dat)
start.dat.list <- list()
dat.list <- list()
mask.list <- list()
unq.labels <- list()
res.list <- list()
###
for(i in rois){
unq.labels[[i]] <- unique(as.data.frame(spatial.dat[[i]]$MASKS[[mask]]$polygons))
rm(i)
}
all.labs <- unique(rbindlist(unq.labels, fill = TRUE))
all.labs <- all.labs[order(all.labs)]
all.labs <- cbind(all.labs, TEMP_LABEL_PLACEHOLDER1)
all.labs
for(i in rois){
# i <- rois[[8]]
dat.list[[i]] <- cell.dat[cell.dat[[roi.col]] == i,]
coordinates(dat.list[[i]]) <- ~ x + y
mask.list[[i]] <- spatial.dat[[i]]$MASKS[[mask]]$polygons
proj4string(dat.list[[i]]) <- proj4string(mask.list[[i]])
res <- over(dat.list[[i]], mask.list[[i]])
res.list[[i]] <- res[[1]]
}
###
res.dt <- unlist(res.list)
res.dt <- as.data.table(res.dt)
res.dt
if(nrow(cell.dat) != nrow(res.dt)){
stop("Result dt rows are inconsistent with starting dt rows")
}
res.dt <- do.embed.columns(res.dt, "res.dt", all.labs, 'obj_mask')
res.dt
res.dt$res.dt <- NULL
names(res.dt)[length(names(res.dt))] <- name
res.dt
return.dat <- cbind(cell.dat, res.dt)
###
return(return.dat)
}
#' Read TIFF files into R and and create spatial data object
#'
#' @usage read.spatial.files()
#'
#' @param rois
#' @param roi.loc
#' @param multi.tiff
#' @param correct.extent
#' @param flip.y
#' @param value.modifier
#' @param ext
#'
#' @return Returns a spatial data object.
#'
#' @examples
#'
#' @import data.table
#'
#' @export
read.spatial.files <- function(rois,
roi.loc = getwd(),
multi.tiff = FALSE,
correct.extent = TRUE,
flip.y = TRUE,
value.modifier = 65535,
ext = ".tiff"){
### Checks
if(multi.tiff == TRUE){
if(length(grep(".tif", rois)) != length(rois)){
stop("It appears that your list of ROIs are not TIFF stack files, and might be directories full of single TIFFs (i.e. one TIFF per channel. If this is correct, please use 'multi.tiff = FALSE'")
}
}
### Setup
message("This is a developmental Spectre-spatial function that is still in testing phase with limited documentation. We recommend only using this function if you know what you are doing.")
ROI.list <- list()
spatial.dat <- list()
setwd(roi.loc)
### Loop for ROIs -- one TIFF per ROI (i.e. tiff stack)
if(multi.tiff == TRUE){
message("Multi.tiff is not currently supported")
#
#   setwd(roi.loc)
#   ROI.list <- list()
#
#   for(i in rois){
#     # i <- rois[[1]]
#     message(paste0("Reading TIFF file for ", i))
#
#     temp <- readTIFF(i, all = TRUE)
#     str(temp)
#
#     temp <- raster(temp[[1]])
#
#     raster.stack <- stack(active.roi)
#
#
#
#
#
#     raster.stack <- stack(active.roi)
#     ROI.list[[i]]$rasters <- raster.stack
#   }
}
### Loop for ROIs -- one FOLDER per ROI
if(multi.tiff == FALSE){
for(i in rois){
# i <- rois[[1]]
message(paste0("Reading TIFF files for ", i))
setwd(roi.loc)
setwd(i)
tiffs <- list.files(pattern = ext)
## TIFF loop
active.roi <- list()
for(a in tiffs){
# a <- tiffs[[1]]
active.roi[[a]] <- readTIFF(a)
active.roi[[a]] <- raster(active.roi[[a]])
if(correct.extent == TRUE){
extent(active.roi[[a]]) <- c(0, dim(active.roi[[a]])[2], 0,dim(active.roi[[a]])[1]) # Y axis - X axis
}
if(flip.y == TRUE){
active.roi[[a]] <- flip(active.roi[[a]], 'y')
}
values(active.roi[[a]]) <- values(active.roi[[a]])*value.modifier
for(n in c(1:length(names(active.roi)))){
names(active.roi)[n] <- gsub(ext, "", names(active.roi)[n])
}
}
raster.stack <- stack(active.roi)
ROI.list[[i]]$RASTERS <- raster.stack
}
}
### Return
message("Constructing of spatial data object complete")
return(ROI.list)
}
library(Spectre)
package.check()
package.load()
dirname(rstudioapi::getActiveDocumentContext()$path)            # Finds the directory where this script is located
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))     # Sets the working directory to where the script is located
getwd()
start.dir <- getwd()
start.dir
setwd("ROIs/")
roi.dir <- getwd()
rois <- list.dirs(getwd(), full.names = FALSE, recursive = FALSE)
rois
spatial.dat <- read.spatial.files(roi.loc = roi.dir,
rois = rois)
# package.check(type = "spatial")
package.load(type = "spatial")
spatial.dat <- read.spatial.files(roi.loc = roi.dir,
rois = rois)
as.matrix(names(spatial.dat)) # ROI names
names(spatial.dat[[1]]) # only rasters  currently in the data
as.matrix(names(spatial.dat[[1]]$rasters)) # TIFF names of first ROI
as.matrix(names(spatial.dat[[1]]$RASTERS)) # TIFF names of first ROI
setwd(start.dir)
setwd("CPoutput/")
mask.dir <- getwd()
list.files()
mask.ext <- "_ilastik_s2_Probabilities_mask.tiff"
masks <- list.files(pattern = mask.ext)
masks
spatial.dat <- do.add.masks(spatial.dat = spatial.dat,
mask.loc = mask.dir,
masks = masks,
mask.ext = mask.ext,
mask.label = "cell_mask")
names(spatial.dat[[1]])
spatial.dat[[1]]$rasters
spatial.dat[[1]]$RASTERS
spatial.dat[[1]]$MASKS
spatial.dat <- do.create.outlines(spatial.dat = spatial.dat,
mask.name = "cell_mask")
as.matrix(names(spatial.dat[[1]]))
as.matrix(names(spatial.dat[[1]]$MASKS$cell_mask))
setwd(start.dir)
setwd("CPoutput/")
list.files(getwd(), ".csv")
percell.dat <- fread("cell.csv")
image.dat <- fread("Image.csv")
unique(percell.dat$ImageNumber)
add <- image.dat[,c('ImageNumber', 'FileName_CellImage'), with= FALSE]
percell.dat <- do.embed.columns(dat = percell.dat,
base.col = "ImageNumber",
add.dat = add,
add.by = 'ImageNumber')
percell.dat$FileName_CellImage
temp <- gsub("_ilastik_s2_Probabilities_mask.tiff", "", percell.dat$FileName_CellImage)
percell.dat$ImageName <- temp
as.matrix(unique(percell.dat$ImageName)) # Image names
percell.dat$Location_Center_X # X coordinates for per cell data
percell.dat$Location_Center_Y # Y coordinates for per cell data
percell.dat$ImageName
spatial.dat <- do.add.percell(spatial.dat = spatial.dat,
percell.dat = percell.dat,
roi.col = "ImageName",
name = "per.cell")
filters <- c("Intensity_MeanIntensity_FullStack_",
"Intensity_MedianIntensity_FullStack_",
"Intensity_IntegratedIntensity_FullStack_",
"Intensity_MeanIntensity_FullStackFiltered_",
"Intensity_MedianIntensity_FullStackFiltered_",
"Intensity_IntegratedIntensity_FullStackFiltered_")
nms <- gsub("_FullStack", "", filters)
for(i in c(1:length(filters))){
# i <- 1
filter <- filters[[i]]
nm <- nms[[i]]
spatial.dat <- do.filter.percell(spatial.dat = spatial.dat,
per.cell = "per.cell",
to = nm,
filter.by = filter,
id.col = "ObjectNumber",
x.col = "Location_Center_X", # uses x
y.col = "Location_Center_Y", # uses y
simplify.cp.colname = TRUE,
value.modifier = 65535)
}
as.matrix(names(spatial.dat[[1]]))
spatial.dat[[1]]$Intensity_MeanIntensity_
as.matrix(names(spatial.dat[[1]]))
spatial.dat[[1]]$CPDATA$Intensity_MeanIntensity_
spatial.dat[[1]]$CPDATA$Intensity_IntegratedIntensityFiltered_
spatial.dat[[1]]$CPDATA
setwd(start.dir)
setwd("panel/")
panel <- fread("panel.csv")
panel
##
new.names <- panel$Target
as.matrix(new.names)
##
as.matrix(names(spatial.dat[[1]]$Intensity_MeanIntensity_))
target.nums <- c(4:16)
target.names <- names(spatial.dat[[1]]$Intensity_MeanIntensity_)[target.nums]
as.matrix(target.names)
as.matrix(new.names)
##
as.matrix(names(spatial.dat[[1]]$CPDATA$Intensity_MeanIntensity_))
target.nums <- c(4:16)
target.names <- names(spatial.dat[[1]]$CPDATA$Intensity_MeanIntensity_)[target.nums]
as.matrix(target.names)
for(i in names(spatial.dat)){
# i <- names(spatial.dat)[[1]]
for(a in nms){
# a <- nms[[1]]
names(spatial.dat[[i]]$CPDATA[[a]])[target.nums] <- new.names
}
}
as.matrix(names(spatial.dat[[1]]$CPDATA$Intensity_MeanIntensity_))
as.matrix(names(spatial.dat[[1]]$CPDATA$Intensity_IntegratedIntensityFiltered_))
as.matrix(names(spatial.dat[[2]]$CPDATA$Intensity_MeanIntensity_))
as.matrix(names(spatial.dat[[2]]$CPDATA$Intensity_IntegratedIntensityFiltered_))
as.matrix(names(spatial.dat))
as.matrix(names(spatial.dat$`20171228_spleen315_500x500_editedforFAS_s1_p9_r2_a2_ac`$RASTERS))
as.matrix(names(spatial.dat$`20171228_spleen315_500x500_editedforFAS_s1_p9_r2_a2_ac`$CPDATA$Intensity_MeanIntensityFiltered_))
make.spatial.plot(spatial.dat,
image.roi = "20171228_spleen315_500x500_editedforFAS_s1_p9_r2_a2_ac",
image.channel = "CD20_Dy161",
mask.outlines = "cell_mask",
cell.dat = "Intensity_MeanIntensity_",
cell.col = "CD20")
setwd(start.dir)
saveRDS(spatial.dat, file = "spatial.dat.rds")
setwd("/Users/thomasa/Desktop/")
setwd("/Users/thomasa/Desktop/")
save(spatial.dat, file = 'demo.spatial.rdata')
load("/Volumes/GoogleDrive/My Drive/_Sydney Cytometry/Libraries (synced)/GitHub/Public github/SpectreMAP/data/demo.spatial.rdata")
spatial.dat
library(devtools)
library(roxygen2)
setwd("/Users/thomasa/Google Drive File Stream/My Drive/_Sydney Cytometry/Libraries (synced)/GitHub/Public github/SpectreMAP/")
document()
library(devtools)
library(roxygen2)
setwd("/Users/thomasa/Google Drive File Stream/My Drive/_Sydney Cytometry/Libraries (synced)/GitHub/Public github/SpectreMAP/")
document()
warnings()
library(devtools)
library(roxygen2)
setwd("/Users/thomasa/Google Drive File Stream/My Drive/_Sydney Cytometry/Libraries (synced)/GitHub/Public github/SpectreMAP/")
document()
library(devtools)
library(roxygen2)
setwd("/Users/thomasa/Google Drive File Stream/My Drive/_Sydney Cytometry/Libraries (synced)/GitHub/Public github/SpectreMAP/")
document()
library(devtools)
library(roxygen2)
setwd("/Users/thomasa/Google Drive File Stream/My Drive/_Sydney Cytometry/Libraries (synced)/GitHub/Public github/SpectreMAP/")
document()
library(devtools)
library(roxygen2)
setwd("/Users/thomasa/Google Drive File Stream/My Drive/_Sydney Cytometry/Libraries (synced)/GitHub/Public github/SpectreMAP/")
document()
library(devtools)
library(roxygen2)
setwd("/Users/thomasa/Google Drive File Stream/My Drive/_Sydney Cytometry/Libraries (synced)/GitHub/Public github/SpectreMAP/")
document()
warnings()
library(devtools)
library(roxygen2)
setwd("/Users/thomasa/Google Drive File Stream/My Drive/_Sydney Cytometry/Libraries (synced)/GitHub/Public github/SpectreMAP/")
document()
devtools::document()
library(devtools)
library(roxygen2)
setwd("/Users/thomasa/Google Drive File Stream/My Drive/_Sydney Cytometry/Libraries (synced)/GitHub/Public github/SpectreMAP/")
devtools::load_all()
devtools::document()
load("/Volumes/GoogleDrive/My Drive/_Sydney Cytometry/Libraries (synced)/GitHub/Public github/SpectreMAP/data/demo.spatial.RData")
