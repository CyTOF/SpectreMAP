#   }
}
### Return
message("Constructing of spatial data object complete")
return(ROI.list)
}
do.add.masks <- function(spatial.dat,
mask.loc,
masks,
mask.label = "cell_mask",
correct.extent = TRUE,
flip.y = TRUE,
value.modifier = 65535,
mask.ext = "_mask.tiff"){
### Setup
message("This is a developmental Spectre-spatial function that is still in testing phase with limited documentation. We recommend only using this function if you know what you are doing.")
spat.names <- names(spatial.dat)
spat.names
mask.names <- gsub(mask.ext, "", masks)
mask.names
mask.check <- (spat.names == mask.names)
mask.check
### Read in mask files
setwd(mask.loc)
for(i in spat.names){
# i <- "20171228_spleen315_500x500_editedforFAS_s1_p9_r2_a2_ac"
mask.img <- readTIFF(paste0(spat.names, mask.ext))
mask.img <- raster(mask.img)
if(correct.extent == TRUE){
extent(mask.img) <- c(0, dim(mask.img)[2], 0,dim(mask.img)[1]) # Y axis - X axis
}
if(flip.y == TRUE){
mask.img <- flip(mask.img, 'y')
}
values(mask.img) <- values(mask.img)*value.modifier
names(mask.img) <- mask.label
spatial.dat[[i]][[mask.label]]$masks <- mask.img
}
message("Returning spatial data object with added masks")
return(spatial.dat)
}
do.create.outlines <- function(spatial.dat,
mask.name){
### Setup
message("This is a developmental Spectre-spatial function that is still in testing phase with limited documentation. We recommend only using this function if you know what you are doing.")
# polygons.name <- paste0(mask.name, "_polygons")
# outlines.name <- paste0(mask.name, "_outlines")
# centroids.name <- paste0(mask.name, "_centroids")
### Run
for(i in names(spatial.dat)){
# i <- "20171228_spleen315_500x500_editedforFAS_s1_p9_r2_a2_ac"
mask <- spatial.dat[[i]][[mask.name]]$masks
message(paste0("Creating polygons, outlines, and centroids for", i, "... this step may take some time -- please be patient"))
polygon <- rasterToPolygons(mask, dissolve=TRUE)
spatial.dat[[i]][[mask.name]][["polygons"]] <- polygon
outline <- fortify(polygon)
spatial.dat[[i]][[mask.name]][["outlines"]] <- outline
centroids <- gCentroid(polygon,byid=TRUE)
spatial.dat[[i]][[mask.name]][["centroids"]] <- centroids
}
# spatial.dat[[1]]$rasters
# spatial.dat[[1]]$cell_mask
# spatial.dat[[1]]$cell_mask_polygons
# spatial.dat[[1]]$cell_mask_outlines
# spatial.dat[[1]]$cell_mask_centroids
message("Returning spatial data")
return(spatial.dat)
}
do.add.percell <- function(spatial.dat,
percell.dat,
roi.col,
name = "per.cell"){
### Setup
message("This is a developmental Spectre-spatial function that is still in testing phase with limited documentation. We recommend only using this function if you know what you are doing.")
### Loop
for(i in names(spatial.dat)){
# i <- "20171228_spleen315_500x500_editedforFAS_s1_p9_r2_a2_ac"
temp <- percell.dat[percell.dat[[roi.col]] == i,]
spatial.dat[[i]][[name]] <- temp
}
return(spatial.dat)
}
do.filter.percell <- function(spatial.dat,
per.cell,
to,
filter.by,
id.col = "ObjectNumber",
x.col = "Location_Center_X",
y.col = "Location_Center_Y",
simplify.cp.colname = TRUE,
value.modifier = 65535){
### Setup
message("This is a developmental Spectre-spatial function that is still in testing phase with limited documentation. We recommend only using this function if you know what you are doing.")
### Loop
for(i in names(spatial.dat)){
# i <- "20171228_spleen315_500x500_editedforFAS_s1_p9_r2_a2_ac"
temp <- spatial.dat[[i]][[per.cell]]
temp.filtered <- temp[,grepl( filter.by , names(temp)),with = FALSE]
temp.filtered <- temp.filtered * value.modifier
temp.filtered <- cbind(ID = temp[[id.col]],x = temp[[x.col]], y = temp[[y.col]], temp.filtered)
if(simplify.cp.colname == TRUE){
measr <- temp.filtered[,c(1:3),with = FALSE]
chnls <- temp.filtered[,c(4:length(names(temp.filtered))),with = FALSE]
names(chnls) <- sub('.*\\_c', '', names(chnls))
temp.names <- names(chnls)
for(b in c(1:length(temp.names))){
a <- temp.names[[b]]
if(nchar(a) == 1){
a <- paste0("0", a)
}
temp.names[[b]] <- a
}
names(chnls) <- temp.names
neworder <- sort(names(chnls))
chnls <- setcolorder(chnls, neworder)
temp.filtered <- cbind(measr, chnls)
}
spatial.dat[[i]][[to]] <- temp.filtered
}
### Return
return(spatial.dat)
}
do.extract.cell.dat <- function(spatial.dat,
target.dat){
### Setup
message("This is a developmental Spectre-spatial function that is still in testing phase with limited documentation. We recommend only using this function if you know what you are doing.")
### Extract
dat.list <- list()
for(i in names(spatial.dat)){
roi.dat <- spatial.dat[[i]][[target.dat]]
nme.vec <- rep(i, nrow(roi.dat))
roi.dat <- cbind("ROI" = nme.vec, roi.dat)
dat.list[[i]] <- roi.dat
}
dat.dt <- rbindlist(dat.list, fill = TRUE)
return(dat.dt)
}
make.spatial.plot <- function(spatial.dat, # spatial data object
image.roi, # name of ROI
image.channel, # name of channel
## Options for adding cell outlines
mask.outlines = NULL, # character -- the outlines in spatial.dat object
## Options for adding cellular data
cell.dat = NULL, # can be character (if it's data within spatial.dat) or a data.table
cell.col = NULL, # column for colouration
## Other settings (with defaults)
image.y.flip = TRUE,
image.mask.size = 0.1,
image.mask.colour = "gold",
image.min.threshold = 0.00,
image.max.threshold = 0.99,
image.blank = FALSE,
cell.x = "x",
cell.y = "y",
cell.col.type = "numeric",
cell.colours = "spectral",
cell.col.min.threshold = 0.01,
cell.col.max.threshold = 0.995,
title = paste0(image.roi),
dot.size = 1,
dot.alpha = 1,
align.xy.by = cell.dat, # choose a data frame to set absolute limits for X/Y/colour
align.col.by = cell.dat,
save.to.disk = TRUE,
path = getwd(),
plot.width = 9,
plot.height = 7,
blank.axis = FALSE)
{
### TESTING
# library(raster)
# library(data.table)
# library(tiff)
# library(ggplot2)
#
# spatial.dat = spatial.dat
#
# spatial.dat$meta.data
#
# roi = "20171228_spleen315_500x500_editedforFAS_s1_p9_r2_a2_ac"
# roi.marker = "CD20_Dy161"
# cell.dat <- spatial.dat$cell.dat.means.filtered
# cell.dat <- cell.dat[cell.dat[["ImageName"]] == "20171228_spleen315_500x500_editedforFAS_s1_p9_r2_a2_ac_ilastik_s2_Probabilities_mask.tiff",]
# cell.dat = cell.dat
# cell.x = "X"
# cell.y = "Y"
# cell.colour = 'CD20'
#
# add.outlines = TRUE
# flip.y.axis = TRUE
message("This is a developmental Spectre-spatial function that is still in testing phase with limited documentation. We recommend only using this function if you know what you are doing.")
### Check that necessary packages are installed
if(!is.element('Spectre', installed.packages()[,1])) stop('Spectre is required but not installed')
if(!is.element('ggplot2', installed.packages()[,1])) stop('ggplot2 is required but not installed')
if(!is.element('scales', installed.packages()[,1])) stop('scales is required but not installed')
if(!is.element('colorRamps', installed.packages()[,1])) stop('colorRamps is required but not installed')
if(!is.element('ggthemes', installed.packages()[,1])) stop('ggthemes is required but not installed')
if(!is.element('RColorBrewer', installed.packages()[,1])) stop('RColorBrewer is required but not installed')
if(!is.element('raster', installed.packages()[,1])) stop('raster is required but not installed')
if(!is.element('rgeos', installed.packages()[,1])) stop('rgeos is required but not installed')
### Require packages
require(Spectre)
require(ggplot2)
require(scales)
require(colorRamps)
require(ggthemes)
require(RColorBrewer)
require(raster)
require(rgeos)
### Compatability conversions
roi <- image.roi
roi.marker <- image.channel
#cell.dat
cell.colour <- cell.col
add.outlines <- image.outlines <- mask.outlines
flip.y.axis <- image.y.flip
cell.colour.type <- cell.col.type
raster.mask.size <- image.mask.size
raster.mask.colour <- image.mask.colour
raster.min.threshold <- image.min.threshold
raster.max.threshold <- image.max.threshold
col.min.threshold <- cell.col.min.threshold
col.max.threshold <- cell.col.max.threshold
colours <- cell.colours
### Colour setup
# Jet
if(colours == "jet"){
colour.scheme <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan", "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))
}
# Spectral
if(colours == "spectral"){
spectral.list <- colorRampPalette(brewer.pal(11,"Spectral"))(50)
spectral.list <- rev(spectral.list)
colour.scheme <- colorRampPalette(c(spectral.list))
}
# Viridis
if(colours == "viridis"){
colour.scheme <- colorRampPalette(c(viridis_pal(option = "viridis")(50)))
}
# Inferno
if(colours == "inferno"){
colour.scheme <- colorRampPalette(c(viridis_pal(option = "inferno")(50)))
}
#Magma
if(colours == "magma"){
colour.scheme <- colorRampPalette(c(viridis_pal(option = "magma")(50)))
}
### cell.dat setup
if(!is.null(cell.dat)){
if(is.character(cell.dat) == TRUE){
temp <- spatial.dat[[roi]][[cell.dat]]
cell.dat <- temp
}
if(cell.colour.type == "numeric"){
# Dot point colouration
if(is.null(align.col.by) == TRUE){
ColrMin <- quantile(cell.dat[[cell.colour]], probs = c(col.min.threshold))
ColrMax <- quantile(cell.dat[[cell.colour]], probs = c(col.max.threshold))
}
if(is.null(align.col.by) == FALSE){
ColrMin <- quantile(align.col.by[[cell.colour]], probs = c(col.min.threshold))
ColrMax <- quantile(align.col.by[[cell.colour]], probs = c(col.max.threshold))
}
}
}
### Preparat the raster data
## Image prep
raster.image <- spatial.dat[[roi]]$rasters[[roi.marker]]
tiff.p <- rasterToPoints(raster.image)
tiff.df <- data.frame(tiff.p)
raster.label <- names(tiff.df)[3]
colnames(tiff.df) <- c("x_axis", "y_axis", raster.label)
## Create cell outlines
if(!is.null(mask.outlines)){
outline <- spatial.dat[[roi]][[mask.outlines]]$outlines
centroids <- spatial.dat[[roi]][[mask.outlines]]$centroids
centroid.xmin <- centroids@bbox[1]
centroid.xmax <- centroids@bbox[3]
centroid.ymin <- centroids@bbox[2]
centroid.ymax <- centroids@bbox[4]
}
## Flip y-axis values
# if(flip.y.axis == TRUE){
#   dat <- invert.y.axis(dat, y.axis)
# }
## Normalise XY for cell centroids
plot.normalize <- function(dat, min, max){
return(((dat- min(dat)) / (max(dat)-min(dat))) * (max - min) + min)
}
if(!is.null(cell.dat)){
# X AXIS
cell.dat[[cell.x]] <- plot.normalize(cell.dat[[cell.x]], min = centroid.xmin, max = centroid.xmax)
# Y AXIS
cell.dat[[cell.y]] <- plot.normalize(cell.dat[[cell.y]], min = centroid.ymin, max = centroid.ymax)
}
## Raster colour limits
RastMin <- quantile(tiff.df[[3]], probs = c(raster.min.threshold))
RastMax <- quantile(tiff.df[[3]], probs = c(raster.max.threshold))
###############################################
### Add a check to see if centroids line up ###
###############################################
### Generate and show coloured plot
if(image.blank == FALSE){
p <- ggplot(data=tiff.df, aes(x=tiff.df[[1]], y=tiff.df[[2]])) +
## Plot the raster (IMC image)
geom_raster(aes(fill=tiff.df[[3]])) +
scale_fill_gradient(raster.label,
low = "black",
high = "white",
limits=c(RastMin,RastMax),
oob=squish)
}
if(image.blank == TRUE){
p <- ggplot(data=tiff.df, aes(x=tiff.df[[1]], y=tiff.df[[2]])) +
## Plot the raster (IMC image)
geom_raster(aes(fill=tiff.df[[3]])) +
scale_fill_gradient(raster.label,
low = "black",
high = "black",
limits=c(RastMin,RastMax),
oob=squish)
}
### Plot the cell mask boundaries
if(!is.null(image.outlines)){
p <- p + geom_path(aes(x = long, y = lat, group = group),
data = outline,
size = raster.mask.size,
col = raster.mask.colour)
}
## Plot the cellular data
if(!is.null(cell.dat)){
if(cell.colour.type == "numeric"){
p <- p + geom_point(data=cell.dat,
aes(x=cell.dat[[cell.x]], y=cell.dat[[cell.y]], color = cell.dat[[cell.colour]]),  #as.numeric(as.character(col))
size = dot.size, #dot.size
alpha = dot.alpha # shape = 1
) +
scale_color_gradientn(colours = colour.scheme(50),
limits = (c(ColrMin,ColrMax)),
oob=squish,
name = cell.colour)
}
if(cell.colour.type != "numeric"){
p <- p + geom_point(data=cell.dat,
aes(x=cell.dat[[cell.x]], y=cell.dat[[cell.y]], color = as.factor(cell.dat[[cell.colour]])),  #as.numeric(as.character(col))
size = dot.size, #dot.size
alpha = dot.alpha # shape = 1
) +
scale_colour_discrete(name = cell.colour)
}
}
## Setup some themes
p <- p + theme_bw() +
coord_equal() +
xlab(cell.x)+
ylab(cell.y)+
ggtitle(title)
## More themes
p <- p + theme(panel.background = element_rect(fill = "white", colour = "black", size = 0.5), # change 'colour' to black for informative axis
axis.title.x=element_text(color="Black", face="bold", size=18),
axis.title.y=element_text(color="Black", face="bold", size=18),
legend.text=element_text(size=12), # large = 30 # small = 8
legend.key.height=unit(1,"cm"), # large = 3 # small = 1.2
legend.key.width=unit(0.4,"cm"), # large = 1 # small = 0.4
#legend.title=element_blank(),
plot.title = element_text(color="Black", face="bold", size=16, hjust=0) # size 70 for large, # 18 for small
)
if(flip.y.axis == TRUE){
p <- p + scale_y_reverse()
}
### Save ggplot to disk if desired
if(save.to.disk == TRUE){
ggsave(filename = paste0(title, "_ROI_", roi.marker, "_marker_", cell.colour,".png"),
plot = p,
path = path,
width = plot.width,
height = plot.height,
limitsize = FALSE)
}
print(p)
}
spatial.dat <- do.add.percell(spatial.dat = spatial.dat,
percell.dat = percell.dat,
roi.col = "ImageName",
name = "per.cell")
spatial.dat
percell.dat
as.matrix(unique(percell.dat$ImageName)) # Image names
unique(percell.dat$ImageNumber)
add <- image.dat[,c('ImageNumber', 'FileName_CellImage'), with= FALSE]
add
percell.dat <- fread("cell.csv")
percell.dat
percell.dat <- do.embed.columns(dat = percell.dat,
base.col = "ImageNumber",
add.dat = add,
add.by = 'ImageNumber')
percell.dat$FileName_CellImage
temp <- gsub("_ilastik_s2_Probabilities_mask.tiff", "", percell.dat$FileName_CellImage)
percell.dat$ImageName <- temp
percell.dat
percell.dat$Location_Center_X # X coordinates for per cell data
percell.dat$Location_Center_X # X coordinates for per cell data
percell.dat$Location_Center_Y # Y coordinates for per cell data
as.matrix(unique(percell.dat$ImageName)) # Image names
percell.dat$ImageName
percell.dat
spatial.dat <- do.add.percell(spatial.dat = spatial.dat,
percell.dat = percell.dat,
roi.col = "ImageName",
name = "per.cell")
spatial.dat
names(spatial.dat)
i <- "20171228_spleen315_500x500_editedforFAS_s1_p9_r2_a2_ac"
percell.dat[percell.dat[[roi.col]] == i,]
roi.col = "ImageName"
percell.dat[percell.dat[[roi.col]] == i,]
# i <- "20171228_spleen315_500x500_editedforFAS_s1_p9_r2_a2_ac"
temp <- percell.dat[percell.dat[[roi.col]] == i,]
temp
spatial.dat[[i]][[name]] <- temp
name = "per.cell"
spatial.dat[[i]][[name]] <- temp
spatial.dat
head(spatial.dat)
head(percell.dat)
percell[5,]
percell.dat
percell.dat[5,]
View(percell.dat)
do.add.percell <- function(spatial.dat,
percell.dat,
roi.col,
name = "per.cell"){
### Setup
message("This is a developmental Spectre-spatial function that is still in testing phase with limited documentation. We recommend only using this function if you know what you are doing.")
### Loop
for(i in names(spatial.dat)){
# i <- "20171228_spleen315_500x500_editedforFAS_s1_p9_r2_a2_ac"
temp <- percell.dat[percell.dat[[roi.col]] == i,]
spatial.dat[[i]][[name]] <- temp
}
return(spatial.dat)
}
spatial.dat[[i]][[name]]
for(i in names(spatial.dat)){
# i <- "20171228_spleen315_500x500_editedforFAS_s1_p9_r2_a2_ac"
temp <- percell.dat[percell.dat[[roi.col]] == i,]
spatial.dat[[i]][[name]] <- temp
}
spatial.dat
percell.dat[percell.dat[[roi.col]] == i,]
# i <- "20171228_spleen315_500x500_editedforFAS_s1_p9_r2_a2_ac"
temp <- percell.dat[percell.dat[[roi.col]] == i,]
temp
spatial.dat[[i]][[name]]
filters <- c("Intensity_MeanIntensity_FullStack_",
"Intensity_MedianIntensity_FullStack_",
"Intensity_IntegratedIntensity_FullStack_",
"Intensity_MeanIntensity_FullStackFiltered_",
"Intensity_MedianIntensity_FullStackFiltered_",
"Intensity_IntegratedIntensity_FullStackFiltered_")
nms <- gsub("_FullStack", "", filters)
for(i in c(1:length(filters))){
# i <- 1
filter <- filters[[i]]
nm <- nms[[i]]
spatial.dat <- do.filter.percell(spatial.dat = spatial.dat,
per.cell = "per.cell",
to = nm,
filter.by = filter,
id.col = "ObjectNumber",
x.col = "Location_Center_X", # uses x
y.col = "Location_Center_Y", # uses y
simplify.cp.colname = TRUE,
value.modifier = 65535)
}
as.matrix(names(spatial.dat[[1]]))
spatial.dat[[1]]$Intensity_MeanIntensity_
spatial.dat[[1]]$Intensity_IntegratedIntensityFiltered_
setwd(start.dir)
setwd("panel/")
panel <- fread("panel.csv")
panel
##
new.names <- panel$Target
as.matrix(new.names)
##
as.matrix(names(spatial.dat[[1]]$Intensity_MeanIntensity_))
target.nums <- c(4:16)
target.names <- names(spatial.dat[[1]]$Intensity_MeanIntensity_)[target.nums]
as.matrix(target.names)
for(i in names(spatial.dat)){
# i <- names(spatial.dat)[[1]]
for(a in nms){
# a <- nms[[1]]
names(spatial.dat[[i]][[a]])[target.nums] <- new.names
}
}
as.matrix(names(spatial.dat[[1]]$Intensity_MeanIntensity_))
as.matrix(names(spatial.dat[[1]]$Intensity_IntegratedIntensityFiltered_))
as.matrix(names(spatial.dat[[2]]$Intensity_MeanIntensity_))
as.matrix(names(spatial.dat[[2]]$Intensity_IntegratedIntensityFiltered_))
as.matrix(names(spatial.dat))
as.matrix(names(spatial.dat$`20171228_spleen315_500x500_editedforFAS_s1_p9_r2_a2_ac`$rasters))
as.matrix(names(spatial.dat$`20171228_spleen315_500x500_editedforFAS_s1_p9_r2_a2_ac`$Intensity_MeanIntensityFiltered_))
make.spatial.plot(spatial.dat,
image.roi = "20171228_spleen315_500x500_editedforFAS_s1_p9_r2_a2_ac",
image.channel = "CD20_Dy161",
mask.outlines = "cell_mask",
cell.dat = "Intensity_MeanIntensity_",
cell.col = "CD20")
